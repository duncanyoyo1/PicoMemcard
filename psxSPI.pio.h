// -------------------------------------------------- //
// This file is autogenerated by pioasm; do not edit! //
// -------------------------------------------------- //

#pragma once

#if !PICO_NO_HARDWARE
#include "hardware/pio.h"
#endif

#define PIN_DAT 5
#define PIN_CMD 6
#define PIN_SEL 7
#define PIN_CLK 8
#define PIN_ACK 9

// ---------- //
// cmd_reader //
// ---------- //

#define cmd_reader_wrap_target 2
#define cmd_reader_wrap 4

static const uint16_t cmd_reader_program_instructions[] = {
    0x2007, //  0: wait   0 gpio, 7                  
    0xe027, //  1: set    x, 7                       
            //     .wrap_target
    0x2008, //  2: wait   0 gpio, 8                  
    0x2088, //  3: wait   1 gpio, 8                  
    0x4001, //  4: in     pins, 1                    
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program cmd_reader_program = {
    .instructions = cmd_reader_program_instructions,
    .length = 5,
    .origin = -1,
};

static inline pio_sm_config cmd_reader_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + cmd_reader_wrap_target, offset + cmd_reader_wrap);
    return c;
}
#endif

// ---------- //
// dat_reader //
// ---------- //

#define dat_reader_wrap_target 1
#define dat_reader_wrap 3

static const uint16_t dat_reader_program_instructions[] = {
    0x2007, //  0: wait   0 gpio, 7                  
            //     .wrap_target
    0x2008, //  1: wait   0 gpio, 8                  
    0x2088, //  2: wait   1 gpio, 8                  
    0x4001, //  3: in     pins, 1                    
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program dat_reader_program = {
    .instructions = dat_reader_program_instructions,
    .length = 4,
    .origin = -1,
};

static inline pio_sm_config dat_reader_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + dat_reader_wrap_target, offset + dat_reader_wrap);
    return c;
}
#endif

// ---------- //
// dat_writer //
// ---------- //

#define dat_writer_wrap_target 2
#define dat_writer_wrap 8

static const uint16_t dat_writer_program_instructions[] = {
    0xe080, //  0: set    pindirs, 0      side 0     
    0x2007, //  1: wait   0 gpio, 7       side 0     
            //     .wrap_target
    0x80a0, //  2: pull   block           side 0     
    0xb542, //  3: nop                    side 1 [5] 
    0xe527, //  4: set    x, 7            side 0 [5] 
    0x2088, //  5: wait   1 gpio, 8       side 0     
    0x2008, //  6: wait   0 gpio, 8       side 0     
    0x6081, //  7: out    pindirs, 1      side 0     
    0x0045, //  8: jmp    x--, 5          side 0     
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program dat_writer_program = {
    .instructions = dat_writer_program_instructions,
    .length = 9,
    .origin = -1,
};

static inline pio_sm_config dat_writer_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + dat_writer_wrap_target, offset + dat_writer_wrap);
    sm_config_set_sideset(&c, 1, false, true);
    return c;
}

#define SLOW_CLKDIV 50	// 125MHz divided down to 2.5 MHz - we need this so we don't count clocks not meant for us on systems like the PS2
static inline void cmd_reader_program_init(PIO pio, uint sm, uint offset) {
	pio_sm_config c = cmd_reader_program_get_default_config(offset);
	/* Pin Configuration */
	sm_config_set_in_pins(&c, PIN_CMD);
	pio_sm_set_consecutive_pindirs(pio, sm, PIN_CMD, 1, false);
	pio_sm_set_consecutive_pindirs(pio, sm, PIN_SEL, 1, false);
	pio_sm_set_consecutive_pindirs(pio, sm, PIN_CLK, 1, false);
	/* Fifo Configuration */
	sm_config_set_in_shift(&c, true, true, 8);		// shift ISR to right, autopush every 8 bits
	sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);	// join RX FIFO
	/* Clock configuration */
    sm_config_set_clkdiv_int_frac(&c, SLOW_CLKDIV, 0x00);
	/* Initialize SM */
	pio_sm_init(pio, sm, offset, &c);
}
static inline void dat_reader_program_init(PIO pio, uint sm, uint offset) {
	pio_sm_config c = dat_reader_program_get_default_config(offset);
	/* Pin Configuration */
	sm_config_set_in_pins(&c, PIN_DAT);
	pio_sm_set_consecutive_pindirs(pio, sm, PIN_DAT, 1, false);
	pio_sm_set_consecutive_pindirs(pio, sm, PIN_SEL, 1, false);
	pio_sm_set_consecutive_pindirs(pio, sm, PIN_CLK, 1, false);
	/* Fifo Configuration */
	sm_config_set_in_shift(&c, true, true, 8);		// shift ISR to right, autopush every 8 bits
	sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);	// join RX FIFO
    /* Clock configuration */
    sm_config_set_clkdiv_int_frac(&c, SLOW_CLKDIV, 0x00);
	/* Initialize SM */
	pio_sm_init(pio, sm, offset, &c);
}
static inline void dat_writer_program_init(PIO pio, uint sm, uint offset) {
	pio_sm_config c = dat_writer_program_get_default_config(offset);
	/* Pin Configuration */
	sm_config_set_out_pins(&c, PIN_DAT, 1);		// set base OUT pin (DAT)
	sm_config_set_set_pins(&c, PIN_DAT, 1);		// set base SET pin (DAT)
	sm_config_set_sideset_pins(&c, PIN_ACK);	// set base SIDESET pin (ACK)
    /* configure DAT pin for open drain (output low but set as input initially) */
	pio_sm_set_pins_with_mask(pio, sm, 0, 1 << PIN_DAT);
	pio_sm_set_consecutive_pindirs(pio, sm, PIN_DAT, 1, false);
	pio_gpio_init(pio, PIN_DAT);
    /* configure ACK pin for open drain (output low but set as input initially) */
	pio_sm_set_pins_with_mask(pio, sm, 0, 1 << PIN_ACK);
	pio_sm_set_consecutive_pindirs(pio, sm, PIN_ACK, 1, false);
	pio_gpio_init(pio, PIN_ACK);
	pio_sm_set_consecutive_pindirs(pio, sm, PIN_SEL, 1, false);
	pio_sm_set_consecutive_pindirs(pio, sm, PIN_CLK, 1, false);
	/* FIFO Configuration */
	sm_config_set_out_shift(&c, true, true, 8);		// shift OSR to right, autopull every 8 bits
	sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_TX);	// join TX FIFO
    /* Clock configuration */
    sm_config_set_clkdiv_int_frac(&c, SLOW_CLKDIV, 0x00);
	/* Initialize SM */
	pio_sm_init(pio, sm, offset, &c);
}
static inline uint8_t read_byte_blocking(PIO pio, uint sm) {
	return (uint8_t) (pio_sm_get_blocking(pio, sm) >> 24);
}
static inline void write_byte_blocking(PIO pio, uint sm, uint32_t byte) {
	pio_sm_put_blocking(pio, sm, ~byte & 0xFF); // invert bits (0 become 1 setting the output to low)
}

#endif

